<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Image Asset Extractor with Outline & Selection</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f9f9f9; }
    #images { display: flex; flex-wrap: wrap; gap: 20px; margin-top: 1em; position: relative; }
    canvas { border: 1px solid #ccc; background: white; cursor: pointer; transition: box-shadow 0.2s; }
    canvas.selected { box-shadow: 0 0 0 4px lightblue; }
    label { font-weight: bold; margin-right: 1em; }
    .bar-container { width: 400px; height: 20px; background: #ddd; margin: 10px 0; }
    .bar { height: 100%; background: #76c7c0; width: 0%; transition: width 0.3s ease; }
    .selection-box { 
      position: absolute; 
      border: 2px dashed #007acc; 
      background: rgba(0, 122, 204, 0.1); 
      pointer-events: none; 
      z-index: 1000; 
    }
  </style>
</head>
<body>
  <h2>Upload, Extract, Outline & Download Image Assets</h2>

  <input type="file" id="upload" accept="image/*" multiple>
  <div class="bar-container"><div id="uploadBar" class="bar"></div></div>

  <br>
  <label>Outline Color:
    <input type="color" id="outlineColor" value="#000000">
  </label>

  <label style="margin-left: 2em;">Thickness:
    <input type="range" id="thickness" min="0" max="20" value="3">
    <span id="thicknessValue">3</span>px
  </label>

    <label style="margin-left: 2em;">Output Size:
      <input type="range" id="outputSize" min="100" max="1000" value="400">
      <span id="outputSizeValue">400</span>px
    </label>

  <br><br>
  <label>
    <input type="checkbox" id="spriteMode"> Sprite Mode (tight fit with 20px padding)
  </label>

  <br><br>
  <button id="selectAll">Select All</button>
  <button id="deselectAll">Deselect All</button>
  <button id="downloadSelected">Download Selected Images</button>

  <div id="images"></div>

  <script>
    const upload = document.getElementById('upload');
    const uploadBar = document.getElementById('uploadBar');
    const outlineColor = document.getElementById('outlineColor');
    const thicknessSlider = document.getElementById('thickness');
    const thicknessValue = document.getElementById('thicknessValue');
      const outputSizeSlider = document.getElementById('outputSize');
      const outputSizeValue = document.getElementById('outputSizeValue');
    const imagesDiv = document.getElementById('images');
    const downloadSelected = document.getElementById('downloadSelected');
    const selectAllBtn = document.getElementById('selectAll');
    const deselectAllBtn = document.getElementById('deselectAll');
    const spriteMode = document.getElementById('spriteMode');

    // Drag selection variables
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let selectionBox = null;

    thicknessSlider.addEventListener('input', () => {
      thicknessValue.textContent = thicknessSlider.value;
    });

      outputSizeSlider.addEventListener('input', () => {
        outputSizeValue.textContent = outputSizeSlider.value;
      });

    // Drag selection functionality
    imagesDiv.addEventListener('mousedown', (e) => {
      if (e.target === imagesDiv) {
        isDragging = true;
        const rect = imagesDiv.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = startX + 'px';
        selectionBox.style.top = startY + 'px';
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        imagesDiv.appendChild(selectionBox);
        
        e.preventDefault();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging && selectionBox) {
        const rect = imagesDiv.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        
        selectionBox.style.left = left + 'px';
        selectionBox.style.top = top + 'px';
        selectionBox.style.width = width + 'px';
        selectionBox.style.height = height + 'px';
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (isDragging && selectionBox) {
        const rect = imagesDiv.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        
        // Find canvases that intersect with selection box
        const canvases = imagesDiv.querySelectorAll('canvas');
        canvases.forEach(canvas => {
          const canvasRect = canvas.getBoundingClientRect();
          const canvasLeft = canvasRect.left - rect.left;
          const canvasTop = canvasRect.top - rect.top;
          const canvasRight = canvasLeft + canvasRect.width;
          const canvasBottom = canvasTop + canvasRect.height;
          
          // Check if canvas intersects with selection box
          if (left < canvasRight && left + width > canvasLeft && 
              top < canvasBottom && top + height > canvasTop) {
            // Toggle selection state - if selected, deselect; if deselected, select
            canvas.classList.toggle('selected');
          }
        });
        
        // Remove selection box
        selectionBox.remove();
        selectionBox = null;
        isDragging = false;
      }
    });

    function setBar(percent) {
      uploadBar.style.width = percent + '%';
    }

    function cleanupSmallArtifacts(imageData, width, height) {
      const visited = new Uint8Array(width * height);
      const minSize = 10; // Minimum size threshold (10x10 pixels = 100 pixels total)
      
      function floodFillAndMeasure(startX, startY) {
        const queue = [[startX, startY]];
        const pixels = [];
        let minX = startX, maxX = startX, minY = startY, maxY = startY;

        while (queue.length > 0) {
          const [x, y] = queue.pop();
          const idx = y * width + x;
          
          if (x < 0 || y < 0 || x >= width || y >= height) continue;
          if (visited[idx]) continue;
          
          const pixelIdx = idx * 4;
          if (imageData.data[pixelIdx + 3] === 0) continue; // Skip transparent pixels
          
          visited[idx] = 1;
          pixels.push([x, y]);
          
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
          
          queue.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
        }
        
        const componentWidth = maxX - minX + 1;
        const componentHeight = maxY - minY + 1;
        
        // If component is smaller than minSize x minSize, mark for deletion
        if (componentWidth < minSize && componentHeight < minSize) {
          pixels.forEach(([px, py]) => {
            const pixelIdx = (py * width + px) * 4;
            imageData.data[pixelIdx + 3] = 0; // Make transparent
          });
        }
        
        return pixels.length > 0;
      }
      
      // Scan all pixels to find and clean small artifacts
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          const pixelIdx = idx * 4;
          
          if (!visited[idx] && imageData.data[pixelIdx + 3] > 0) {
            floodFillAndMeasure(x, y);
          }
        }
      }
    }

    function hexToRgb(hex) {
      return {
        r: parseInt(hex.slice(1, 3), 16),
        g: parseInt(hex.slice(3, 5), 16),
        b: parseInt(hex.slice(5, 7), 16)
      };
    }

    function extractAssets(image) {
      const temp = document.createElement('canvas');
      temp.width = image.width;
      temp.height = image.height;
      const tctx = temp.getContext('2d');
      tctx.drawImage(image, 0, 0);
      const data = tctx.getImageData(0, 0, temp.width, temp.height);

      const visited = new Uint8Array(temp.width * temp.height);
      const components = [];

      function floodFill(x, y, bounds) {
        const queue = [[x, y]];
        const min = { x, y }, max = { x, y };

        while (queue.length > 0) {
          const [cx, cy] = queue.pop();
          const idx = cy * temp.width + cx;
          if (cx < 0 || cy < 0 || cx >= temp.width || cy >= temp.height) continue;
          if (visited[idx]) continue;

          const pixelIdx = idx * 4;
          if (data.data[pixelIdx + 3] === 0) continue;

          visited[idx] = 1;
          min.x = Math.min(min.x, cx);
          min.y = Math.min(min.y, cy);
          max.x = Math.max(max.x, cx);
          max.y = Math.max(max.y, cy);

          queue.push([cx+1, cy]);
          queue.push([cx-1, cy]);
          queue.push([cx, cy+1]);
          queue.push([cx, cy-1]);
        }

        if ((max.x - min.x) > 3 && (max.y - min.y) > 3) {
          components.push({ min, max });
        }
      }

      for (let y = 0; y < temp.height; y++) {
        for (let x = 0; x < temp.width; x++) {
          const idx = y * temp.width + x;
          const a = data.data[idx * 4 + 3];
          if (!visited[idx] && a > 0) {
            floodFill(x, y);
          }
        }
      }

      const outputSize = parseInt(outputSizeSlider.value);
      return components.map((b, i) => {
        const cropW = b.max.x - b.min.x;
        const cropH = b.max.y - b.min.y;

        let canvasWidth, canvasHeight, scale, drawW, drawH, offsetX, offsetY;

        if (spriteMode.checked) {
          // Sprite mode: tight fit with 20px padding
          const padding = 20;
          canvasWidth = cropW + (padding * 2);
          canvasHeight = cropH + (padding * 2);
          scale = 1; // No scaling in sprite mode, use original size
          drawW = cropW;
          drawH = cropH;
          offsetX = padding;
          offsetY = padding;
        } else {
          // Normal mode: square container with proportional scaling
          const paddingRatio = 0.1;
          const usableW = outputSize * (1 - 2 * paddingRatio);
          const usableH = outputSize * (1 - 2 * paddingRatio);
          scale = Math.min(usableW / cropW, usableH / cropH);
          drawW = cropW * scale;
          drawH = cropH * scale;
          offsetX = (outputSize - drawW) / 2;
          offsetY = (outputSize - drawH) / 2;
          canvasWidth = outputSize;
          canvasHeight = outputSize;
        }

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(temp, b.min.x, b.min.y, cropW, cropH, offsetX, offsetY, drawW, drawH);

        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        
        // Clean up small artifacts (smaller than 10x10 pixels)
        cleanupSmallArtifacts(imageData, canvasWidth, canvasHeight);
        
        // Put the cleaned image data back on the canvas
        ctx.putImageData(imageData, 0, 0);
        
        // Get fresh image data for outline processing
        const cleanedImageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const outlined = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const thickness = parseInt(thicknessSlider.value);
        const color = hexToRgb(outlineColor.value);

        for (let y = 0; y < canvasHeight; y++) {
          for (let x = 0; x < canvasWidth; x++) {
            const idx = (y * canvasWidth + x) * 4;
            if (cleanedImageData.data[idx + 3] === 0) continue;
            let edge = false;
            for (let dy = -thickness; dy <= thickness; dy++) {
              for (let dx = -thickness; dx <= thickness; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= canvasWidth || ny >= canvasHeight) continue;
                const nIdx = (ny * canvasWidth + nx) * 4;
                if (cleanedImageData.data[nIdx + 3] === 0) edge = true;
              }
            }
            if (edge) {
              outlined.data[idx] = color.r;
              outlined.data[idx + 1] = color.g;
              outlined.data[idx + 2] = color.b;
              outlined.data[idx + 3] = 255;
            }
          }
        }

        ctx.putImageData(outlined, 0, 0);
        return canvas;
      });
    }

    upload.addEventListener('change', () => {
      const files = Array.from(upload.files);
      if (files.length === 0) return;
      
      setBar(10);
      imagesDiv.innerHTML = '';
      let processedFiles = 0;
      const totalFiles = files.length;
      
      files.forEach((file, fileIndex) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            const assets = extractAssets(img);
            
            assets.forEach((canvas, assetIndex) => {
              canvas.classList.add('selectable');
              canvas.addEventListener('click', (e) => {
                // Only toggle if this wasn't part of a drag operation
                if (!isDragging) {
                  canvas.classList.toggle('selected');
                }
              });
              canvas.setAttribute('data-file-index', fileIndex);
              canvas.setAttribute('data-asset-index', assetIndex);
              imagesDiv.appendChild(canvas);
            });
            
            processedFiles++;
            const progress = 10 + (processedFiles / totalFiles) * 90;
            setBar(progress);
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    });

    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('#images canvas').forEach(canvas => canvas.classList.add('selected'));
    });

    deselectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('#images canvas').forEach(canvas => canvas.classList.remove('selected'));
    });

    downloadSelected.addEventListener('click', () => {
      const selectedCanvases = document.querySelectorAll('#images canvas.selected');
      
      selectedCanvases.forEach((canvas, i) => {
        setTimeout(() => {
          const fileIndex = canvas.getAttribute('data-file-index') || '0';
          const assetIndex = canvas.getAttribute('data-asset-index') || '0';
          const a = document.createElement('a');
          a.href = canvas.toDataURL();
          a.download = `image_${parseInt(fileIndex) + 1}_asset_${parseInt(assetIndex) + 1}.png`;
          a.click();
        }, i * 100); // 100ms delay between each download
      });
    });
  </script>
</body>
</html>
